function HSVtoRGB(h, s, v, opacity) {
  var toHex = function(decimalValue, places) {
    if (places === undefined || isNaN(places))
      places = 2;
    var hex = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"];
    var next = 0;
    var hexidecimal = "";
    decimalValue = Math.floor(decimalValue);
    while (decimalValue > 0) {
      next = decimalValue % 16;
      decimalValue = Math.floor((decimalValue - next) / 16);
      hexidecimal = hex[next] + hexidecimal
    }
    while (hexidecimal.length < places) {
      hexidecimal = "0" + hexidecimal
    }
    return hexidecimal
  };
  var hi = Math.floor(h / 60) % 6;
  var f = h / 60 - Math.floor(h / 60);
  var p = v * (1 - s);
  var q = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);
  var r = v;
  var g = t;
  var b = p;
  switch (hi) {
    case 1:
      r = q;
      g = v;
      b = p;
      break;
    case 2:
      r = p;
      g = v;
      b = t;
      break;
    case 3:
      r = p;
      g = q;
      b = v;
      break;
    case 4:
      r = t;
      g = p;
      b = v;
      break;
    case 5:
      r = v;
      g = p;
      b = q;
      break;
    default:
      break;
  }
  if (opacity) {
    return "rgba(" + Math.round(255 * r) + "," + Math.round(255 * g) + "," + Math.round(255 * b) + "," + opacity + ")"
  } else {
    return "#" + toHex(r * 255) + toHex(g * 255) + toHex(b * 255)
  }
}
function hexToCanvasColor(hexColor, opacity) {
  opacity = opacity || "1.0";
  hexColor = hexColor.replace("#", "");
  var r = parseInt(hexColor.substring(0, 2), 16);
  var g = parseInt(hexColor.substring(2, 4), 16);
  var b = parseInt(hexColor.substring(4, 6), 16);
  return "rgba(" + r + "," + g + "," + b + "," + opacity + ")"
}

function getControlPoints(x0, y0, x1, y1, x2, y2, t) {
  var d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));
  var d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  var fa = t * d01 / (d01 + d12);
  var fb = t - fa;
  var p1x = x1 + fa * (x0 - x2);
  var p1y = y1 + fa * (y0 - y2);
  var p2x = x1 - fb * (x0 - x2);
  var p2y = y1 - fb * (y0 - y2);
  return [p1x, p1y, p2x, p2y]
}

function drawSpline(ctx, pts, t, closed) {
  var showDetails = true;
  if (ctx.lineWidth === 1){
      ctx.lineWidth = 4;
  }
  ctx.save();
  var cp = [];
  var n = pts.length;
  if (closed) {
    var i;
    pts.push(pts[0], pts[1], pts[2], pts[3]);
    pts.unshift(pts[n - 1]);
    pts.unshift(pts[n - 1]);
    for (i = 0; i < n; i += 2) {
      cp = cp.concat(getControlPoints(pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], t))
    }
    cp = cp.concat(cp[0], cp[1]);
    for (i = 2; i < n + 2; i += 2) {
      var color = HSVtoRGB(Math.floor(240 * (i - 2) / (n - 2)), .8, .8);
      if (!showDetails) {
        color = "#555555"
      }
      ctx.strokeStyle = hexToCanvasColor(color, .75);
      ctx.beginPath();
      ctx.moveTo(pts[i], pts[i + 1]);
      ctx.bezierCurveTo(cp[2 * i - 2], cp[2 * i - 1], cp[2 * i], cp[2 * i + 1], pts[i + 2], pts[i + 3]);
      ctx.stroke();
      ctx.closePath()
    }
  } else {
    for (i = 0; i < n - 4; i += 2) {
      cp = cp.concat(getControlPoints(pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], t))
    }
    // console.log(getControlPoints);
    for (i = 2; i < pts.length - 5; i += 2) {
      let color = HSVtoRGB(Math.floor(240 * (i - 2) / (n - 2)), .8, .8);
      if (!showDetails) {
        color = "#555555"
      }
      ctx.strokeStyle = hexToCanvasColor(color, .75);
      ctx.beginPath();
      ctx.moveTo(pts[i], pts[i + 1]);
      ctx.bezierCurveTo(cp[2 * i - 2], cp[2 * i - 1], cp[2 * i], cp[2 * i + 1], pts[i + 2], pts[i + 3]);
      ctx.stroke();
      ctx.closePath()
    }
    let color = HSVtoRGB(40, .4, .4);
    if (!showDetails) {
      color = "#555555"
    }
    ctx.strokeStyle = hexToCanvasColor(color, .75);
    ctx.beginPath();
    ctx.moveTo(pts[0], pts[1]);
    ctx.quadraticCurveTo(cp[0], cp[1], pts[2], pts[3]);
    ctx.stroke();
    ctx.closePath();
    color = HSVtoRGB(240, .8, .8);
    if (!showDetails) {
      color = "#555555"
    }
    ctx.strokeStyle = hexToCanvasColor(color, .75);
    ctx.beginPath();
    ctx.moveTo(pts[n - 2], pts[n - 1]);
    ctx.quadraticCurveTo(cp[2 * n - 10], cp[2 * n - 9], pts[n - 4], pts[n - 3]);
    ctx.stroke();
    ctx.closePath()
  }
  ctx.restore()
}

//
// 'use strict';
// var trackColor = function(socket) {
// //window.onload = function () {
//   var video = document.getElementById('video');
//   var canvas = document.getElementById('canvas');
//   var context = canvas.getContext('2d');
//
//   // console.log(video);
//
//   var drawSegments = [[]];
//   var segment = 0;
//
//   var tracker = new   window.tracking.ColorTracker(['magenta', 'cyan']);
//
//     window.tracking.track('#video', tracker, { camera: true });
//
//   tracker.on('track', function (event) {
//     if (event.data.length === 0 && drawSegments[segment].length > 0) {
//       console.log('segment ++  ' + segment);
//       segment++;
//
//       if (!drawSegments[segment]) {
//         console.log('drawSegments[segment] clear   ' + drawSegments[segment]);
//         drawSegments[segment] = [];
//       }
//     }
//
//     socket.emit('send:rect', event.data);
//     event.data.forEach(function (rect) {
//       if (rect.color === 'magenta') {
//         draw(rect);
//       } else if (rect.color === 'cyan') {
//         erase(rect);
//       }
//     });
//   });
//
//   var draw = function(rect) {
//     drawSegments[segment].push(rect.x + rect.width / 2, rect.y + rect.height / 2);
//   }
//
//   var erase = function (rect) {
//     context.clearRect(rect.x, rect.y, rect.width, rect.height);
//   }
//
//   function isInsideRect (x, y, rect) {
//     return rect.x <= x && x <= rect.x + rect.width && rect.y <= y && y <= rect.y + rect.height;
//   }
//
//   (function loop() {
//     console.log('nami');
//     for (var i = 0, len = drawSegments.length; i < len; i++) {
//       drawSpline(context, drawSegments[i], 0.5, false);
//     }
//
//     drawSegments = [drawSegments[drawSegments.length - 1]];
//     segment = 0;
//
//     requestAnimationFrame(loop);
//   })();
//   return { draw: draw};
// };

module.exports = {
  trackColor: "trackColor",
  drawSpline: drawSpline
};
